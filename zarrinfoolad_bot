import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    ContextTypes,
    ConversationHandler,
    filters,
)

logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)

SELECT_TYPE, GET_DIMENSIONS, GET_PRICE = range(3)
user_data = {}

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [InlineKeyboardButton("ÙˆØ±Ù‚", callback_data='ÙˆØ±Ù‚')],
        [InlineKeyboardButton("Ù…ÛŒÙ„Ú¯Ø±Ø¯", callback_data='Ù…ÛŒÙ„Ú¯Ø±Ø¯')],
        [InlineKeyboardButton("Ù†Ø¨Ø´ÛŒ", callback_data='Ù†Ø¨Ø´ÛŒ')],
        [InlineKeyboardButton("Ù†Ø§ÙˆØ¯Ø§Ù†ÛŒ", callback_data='Ù†Ø§ÙˆØ¯Ø§Ù†ÛŒ')],
        [InlineKeyboardButton("ØªÛŒØ±Ø¢Ù‡Ù†", callback_data='ØªÛŒØ±Ø¢Ù‡Ù†')],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("Ù†ÙˆØ¹ Ø¢Ù‡Ù†â€ŒØ¢Ù„Ø§Øª Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:", reply_markup=reply_markup)
    return SELECT_TYPE

async def select_type(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    user_data[query.from_user.id] = {'type': query.data}
    await query.edit_message_text(f"Ø´Ù…Ø§ '{query.data}' Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø±Ø¯ÛŒØ¯. Ù„Ø·ÙØ§Ù‹ Ù…Ø´Ø®ØµØ§Øª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.")
    await query.message.reply_text("Ù„Ø·ÙØ§Ù‹ Ù…Ø´Ø®ØµØ§Øª Ø±Ø§ Ø¨Ù‡ ØµÙˆØ±Øª Ø²ÛŒØ± ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:\nØ¨Ø±Ø§ÛŒ ÙˆØ±Ù‚: Ø·ÙˆÙ„ØŒ Ø¹Ø±Ø¶ØŒ Ø¶Ø®Ø§Ù…Øª (Ø¨Ø± Ø­Ø³Ø¨ Ù…ØªØ±)\nÙ…Ø«Ø§Ù„: 2 1 0.005")
    return GET_DIMENSIONS

async def get_dimensions(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    try:
        dimensions = list(map(float, update.message.text.strip().split()))
        if len(dimensions) != 3:
            raise ValueError
        user_data[user_id]['dimensions'] = dimensions
        length, width, thickness = dimensions
        volume = length * width * thickness
        density = 7850
        weight = volume * density
        user_data[user_id]['weight'] = weight
        await update.message.reply_text(f"ÙˆØ²Ù† Ù…Ø­Ø§Ø³Ø¨Ù‡â€ŒØ´Ø¯Ù‡: {weight:.2f} Ú©ÛŒÙ„ÙˆÚ¯Ø±Ù…")
        await update.message.reply_text("Ø¨Ø±Ø§ÛŒ Ø§Ø³ØªØ¹Ù„Ø§Ù… Ù‚ÛŒÙ…ØªØŒ Ù„Ø·ÙØ§Ù‹ Ø¨Ø§ Ø´Ù…Ø§Ø±Ù‡ Ø²ÛŒØ± ØªÙ…Ø§Ø³ Ø¨Ú¯ÛŒØ±ÛŒØ¯ Ùˆ Ù‚ÛŒÙ…Øª ÙˆØ§Ø­Ø¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:\nğŸ“ 09123456789\n\nÙ¾Ø³ Ø§Ø² Ø¯Ø±ÛŒØ§ÙØª Ù‚ÛŒÙ…ØªØŒ Ø¢Ù† Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ (Ø¨Ù‡ ØªÙˆÙ…Ø§Ù†):")
        return GET_PRICE
    except ValueError:
        await update.message.reply_text("ÙˆØ±ÙˆØ¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª. Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:")
        return GET_DIMENSIONS

async def get_price(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    try:
        price_per_kg = float(update.message.text.strip())
        weight = user_data[user_id]['weight']
        total_price = weight * price_per_kg
        await update.message.reply_text(f"Ù‚ÛŒÙ…Øª Ú©Ù„: {total_price:,.0f} ØªÙˆÙ…Ø§Ù†")
        return ConversationHandler.END
    except ValueError:
        await update.message.reply_text("ÙˆØ±ÙˆØ¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª. Ù„Ø·ÙØ§Ù‹ Ù‚ÛŒÙ…Øª Ø±Ø§ Ø¨Ù‡ ØµÙˆØ±Øª Ø¹Ø¯Ø¯ÛŒ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:")
        return GET_PRICE

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("Ø¹Ù…Ù„ÛŒØ§Øª Ù„ØºÙˆ Ø´Ø¯.")
    return ConversationHandler.END

def main():
    application = ApplicationBuilder().token("8199021009:AAFKbVrDwfiI-qpMn2bGqFJVEsL8AQdP_3Q").build()

    conv_handler = ConversationHandler(
        entry_points=[CommandHandler("start", start)],
        states={
            SELECT_TYPE: [CallbackQueryHandler(select_type)],
            GET_DIMENSIONS: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_dimensions)],
            GET_PRICE: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_price)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )

    application.add_handler(conv_handler)
    application.run_polling()

if __name__ == "__main__":
    main()
